\section{Амортизационный анализ: групповой анализ, банковский метод. Амортизационный анализ для бинарного счетчика }

В ходе \textbf{амортизационного анализа} (amortized analysis) время, необходимое для выполнения последовательности операций над структурой данных, усредняется по всем выполняемым операциям.
Этот анализ можно использовать, например, чтобы показать, что, даже если одна из операций последовательности является дорогостоящей, при усреднении по всей последовательности средняя стоимость операций будет небольшой.
Амортизационный анализ отличается от анализа средних величин тем, что в нем не учитывается вероятность.
При выполнении амортизационного анализа гарантируется \textit{средняя производительность операций в наихудшем случае}.

\subsection{Групповой анализ}

В ходе \textbf{группового анализа} (aggregate analysis) исследователь показывает, что в наихудшем случае суммарное время выполнения последовательности всех $n$ операций равно $T(n)$.
Поэтому в наихудшем случае средняя, или амортизиро-анная стоимость (amortized cost), приходящаяся на одну операцию, определяется соотношением $T(n)/n$.
Заметим, что такая амортизированная стоимость применима ко всем операциям, даже если в последовательности имеется несколько разных их типов.
В других двух методах (методе бухгалтерского учета и методе потенциалов) операциям различного вида могут присваиваться разные амортизированные стоимости.

\subsubsection{Увеличение показаний бинарного счетчика}

Рассмотрим задачу реализации $k$-битового бинарного счетчика, который ведет счет от нуля в восходящем направлении.
В качестве счетчика используется битовый массив $A[0..k - 1]$, где $A.length = k$.
Младший бит хранящегося в счетчике бинарного числа $x$ находится в элементе $А[0]$, а старший бит --- в элементе $A[k - 1]$, так что $x = \sum_{i = 0}^{k - 1}A[i] \cdot 2^i$.
Чтобы увеличить показания счетчика на 1 (по модулю $2^k$), используется следующая процедура.

\begin{minted}{c}
Increment(А)
    i = О
    while i < A.length и А[i] == 1
        А[i] = О
        i = i + 1
    if i < A.length
        A[i] = 1
\end{minted}

В начале каждой итерации цикла while в строках 2--4 мы добавляем 1 к биту в позиции $i$. Если $A[i] = 1$, то добавление 1 обнуляет бит, который находится на позиции $i$, и приводит к тому, что добавление 1 будет выполнено и в позиции $i + 1$ на следующей операции цикла.
В противном случае цикл оканчивается, так что если по его окончании $i < k$, то $A[i] = 0$ и нам нужно изменить значение $i$-го бита на 1, что и делается в строке 6.
Стоимость каждой операции Increment линейно зависит от количества изменённых битов.

Поверхностный анализ даст правильную, но неточную оценку.
В наихудшем случае, когда массив $A$ состоит только из единиц, для выполнения операции Increment потребуется время $\Theta(k)$.
Таким образом, выполнение последовательности из $n$ операций Increment для изначально обнуленного счетчика в наихудшем случае займет время $O(nk)$.

Этот анализ можно уточнить, в результате чего для последовательности из $n$ операций Increment в наихудшем случае получается стоимость $O(n)$.
Такая оценка возможна благодаря тому, что далеко не при каждом вызове процедуры Increment изменяются значения всех битов. Например, элемент $A[0]$ изменяется при каждом вызове операции Increment.
Следующий по старшинству бит $A[1]$ изменяется только через раз, так что последовательность из $n$ операций Increment над изначально обнуленным счетчиком приводит к изменению элемента $A[1]$ $\lfloor n / 2 \rfloor$ раз.
Аналогично бит $A[2]$ изменяется только каждый четвертый раз, т.е. $\lfloor n / 4 \rfloor$ раз в последовательности из $n$ операций Increment над изначально обнуленным счетчиком.
В общем случае для $i = 0, 1, ... , k - 1$ бит $A[i]$ изменяется $\lfloor n / 2^i \rfloor$ раз в последовательности из п операций Increment над изначально обнуленным счетчиком.
Биты же в позициях $i \ge k$ не изменяются.
Таким образом, общее количество изменений битов при выполнении последовательности операций равно $$\sum_{i = 0}^{k - 1} \Bigl \lfloor \frac{n}{2^i} \Bigr \rfloor < n \sum_{i = 0}^\infty \frac{1}{2^i} = 2n.$$
Поэтому время выполнения последовательности из $n$ операций Increment над изначально обнуленным счетчиком в наихудшем случае равно $O(n)$.
Средняя стоимость каждой операции, а следовательно, и амортизированная стоимость операции, равна $O(n)/n = O(1)$.

\subsection{Метод бухгалтерского учёта}

В \textbf{методе бухгалтерского учета} (accounting method), применяемом в ходе группового анализа, разные операции оцениваются по-разному, в зависимости от их фактической стоимости.
Величина, которая начисляется на операцию, называется амортизированной стоимостью (amortized cost).
Если амортизированная стоимость операции превышает ее фактическую стоимость, то соответствующая разность присваивается определенным объектам структуры данных как кредит (credit).
Кредит можно использовать впоследствии для компенсирующих выплат на операции, амортизированная стоимость которых меньше их фактической стоимости.
Таким образом, можно полагать, что амортизированная стоимость операции состоит из ее фактической стоимости и кредита, который либо накапливается, либо расходуется.
Этот метод существенно отличается от группового анализа, в котором все операции характеризуются одинаковой амортизированной стоимостью.

К выбору амортизированной стоимости следует подходить с осторожностью.
Если нужно провести анализ с использованием амортизированной стоимости, чтобы показать, что в наихудшем случае средняя стоимость операции невелика, полная амортизированная стоимость последовательности операций должна быть верхней границей полной фактической стоимости последовательности.
Более того, как и в групповом анализе, это соотношение должно соблюдаться для всех последовательностей операций.
Если обозначить фактическую стоимость $i$-й операции через $c_i$, а амортизированную стоимость $i$-й операции через $\hat{c_i}$, то указанное требование для всех последовательностей, состоящих из $n$ операций, можно выразить следующим образом: $$\sum_{i = 0}^n \hat{c_i} \ge \sum_{i = 0}^n c_i.$$
Общий кредит, хранящийся в структуре данных, представляет собой разность между полной амортизированной стоимостью и полной фактической стоимостью, или $\sum_{i = 0}^n \hat{c_i} - \sum_{i = 0}^n c_i$.
Соответственно, полный кредит, связанный со
структурой данных, все время должен быть неотрицательным.
Если бы полный кредит в каком-либо случае мог стать отрицательным (в результате недооценки ранних операций с надеждой восполнить счет впоследствии), то полная аморти зированная стоимость в тот момент была бы ниже соответствующей фактической стоимости; значит, для последовательности операций полная амортизированная стоимость не была бы в этот момент времени верхней границей полной фактической стоимости.
Таким образом, необходимо позаботиться о том, чтобы полный кредит для структуры данных никогда не становился отрицательным.

\subsubsection{Увеличение показаний бинарного счетчика}

В качестве примера, иллюстрирующего метод бухгалтерского учета,
проанализируем операцию Increment, которая выполняется над бинарным изначально обнуленным счетчиком.
Ранее мы убедились, что время выполнения этой операции пропорционально количеству битов, изменяющих свое значение.
В данном примере это количество используется в качестве стоимости.
Для представления каждой единицы затрат (в данном случае ---
изменения битов) будет использован денежный счет.

Чтобы провести амортизационный анализ, начислим на операцию, при которой биту присваивается значение 1 (т.е. бит устанавливается), амортизированную стоимость, равную 2 долларам.
Когда бит устанавливается, 1 доллар (из двух начисленных) расходуется на оплату операции по самой установке.
Оставшийся 1 доллар вкладывается в этот бит в качестве кредита для последующего использования при его обнулении.
В любой момент времени с каждой единицей содержащегося в счетчике значения связан 1 доллар кредита, поэтому для обнуления бита нет необходимости начислять какую-либо сумму; за сброс бита достаточно
будет уплатить 1 доллар.

Теперь можно определить амортизированную стоимость операции Increment.
Стоимость обнуления битов в цикле while выплачивается за счет тех денег, которые связаны с этими битами.
В процедуре Increment устанавливается не более одного бита (в строке 6), поэтому амортизированная стоимость операции Increment не превышает 2 долларов.
Количество единиц в бинарном числе, представляющем показания счетчика, не может быть отрицательным, поэтому и сумма кредита всегда неотрицательна.
Таким образом, полная амортизированная стоимость $n$ операций Increment равна $O(n)$.
Это и есть оценка полной фактической стоимости.
