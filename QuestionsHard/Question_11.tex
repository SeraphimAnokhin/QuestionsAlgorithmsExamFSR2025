\section{Расстояние Левенштейна, алгоритм Вагнера --- Фишера}

\begin{definition}
    Расстояние Левенштейна (англ. Levenshtein distance) (также редакционное расстояние или дистанция редактирования) между двумя строками в теории информации и компьютерной лингвистике --- это минимальное количество операций вставки одного символа, удаления одного символа и замены одного символа на другой, необходимых для превращения одной строки в другую.
\end{definition}

Для расстояния Левенштейна справедливы следующие утверждения:

\begin{itemize}
    \item $d(S_1,S_2) \ge \big||S_1|-|S_2| \big|,$
    \item $d(S_1,S_2) \le \max(|S_1|,|S_2|),$
    \item $d(S_1,S_2)=0 \Leftrightarrow S_1=S_2,$
\end{itemize}

где $d(S_1,S_2)$ --- расстояние Левенштейна между строками $S_1$ и $S_2$, а $|S|$ --- длина строки $S$.
Расстояние Левенштейна является метрикой. Для того, чтобы доказать это, достаточно доказать, что выполняется неравенство треугольника:
\begin{itemize}
    \item $d(S_1,S_3) \le d(S_1,S_2) + d(S_2,S_3).$
\end{itemize}

Пусть $d(S_1,S_3) = x$, $d(S_1,S_2) = y$, $d(S_2,S_3) = z$.
Тогда $x$ --- кратчайшее редакционное расстояние от $S_1$ до $S_3$, $y$ --- кратчайшее редакционное расстояние от $S_1$ до $S_2$, а $z$ --- кратчайшее редакционное расстояние от $S_2$ до $S_3$.
При этом $y+z$ --- какое-то расстояние от $S_1$ до $S_3$.
В других случаях $d(S_1,S_3) < d(S_1,S_2) + d(S_2,S_3).$
Следовательно, выполняется неравенство треугольника.

Рассмотрим более общий случай: пусть цены операций могут зависеть от вида операции (вставка, удаление, замена) и/или от участвующих в ней символов.

\begin{lemma}
    Будем считать, что элементы строк нумеруются с первого, как принято в математике, а не нулевого.
    Пусть $S_1$ и $S_2$ --- две строки (длиной $M$ и $N$ соответственно) над некоторым алфавитом, тогда редакционное расстояние $d(S_1,S_2)$ можно подсчитать по следующей рекуррентной формуле: $d(S_1,S_2) = D(M, N)$, где
    \begin{equation*}
        D(i, j) = 
        \begin{cases}
            0 &;i = 0, j = 0\\
            i \cdot deleteCost &;j = 0, i > 0\\
            j \cdot insertCost &;i = 0, j > 0\\
            D(i-1,j-1) &;S_1[i] = S_2[j]\\
            \min(D(i, j - 1) + insertCost,\\
            \ \ \ \ \ \ \ \ D(i - 1, j) + deleteCost, &;i > 0, j > 0, S_1[i] \not= S_2[j]\\
            \ \ \ \ \ \ \ \ D(i - 1, j - 1) + replaceCost).
        \end{cases}
    \end{equation*}
\end{lemma}
\begin{proof}
    Рассмотрим формулу более подробно.
    Здесь $D(i,j)$ --- расстояние между префиксами строк: первыми $i$ символами строки $S_1$ и первыми $j$ символами строки $S_2$.
    Очевидно, что редакционное расстояние между двумя пустыми строками равно нулю.
    Также очевидно то, что чтобы получить пустую строку из строки длиной $i$, нужно совершить $i$ операций удаления, а чтобы получить строку длиной $j$ из пустой, нужно произвести $j$ операций вставки.
    Осталось рассмотреть нетривиальный случай, когда обе строки непусты.

    Для начала заметим, что в оптимальной последовательности операций их можно произвольно менять местами.
    В самом деле, рассмотрим две последовательные операции:

    \begin{itemize}
        \item Две замены одного и того же символа --- неоптимально (если мы заменили $x$ на $y$, потом $y$ на $z$, выгоднее было сразу заменить $x$ на $z$).
        \item Две замены разных символов можно менять местами.
        \item Два стирания или две вставки можно менять местами.
        \item Вставка символа с его последующим стиранием --- неоптимально (можно их обе отменить).
        \item Стирание и вставку разных символов можно менять местами.
        \item Вставка символа с его последующей заменой --- неоптимально (излишняя замена).
        \item Вставка символа и замена другого символа меняются местами.
        \item Замена символа с его последующим стиранием --- неоптимально (излишняя замена).
        \item Стирание символа и замена другого символа меняются местами.
    \end{itemize}

    Пусть $S_1$ кончается на символ $a$, $S_2$ кончается на символ $b$.
    Есть три варианта:
    \begin{enumerate}
        \item Символ $a$, на который кончается $S_1$, в какой-то момент был стёрт.
        Сделаем это стирание первой операцией.
        Тогда мы стёрли символ $a$, после чего превратили первые $i - 1$ символов $S_1$ в $S_2$ (на что потребовалось $D(i-1, j)$ операций), значит, всего потребовалось $D(i-1, j)+1$ операций
        \item Символ $b$, на который кончается $S_2$, в какой-то момент был добавлен.
        Сделаем это добавление последней операцией.
        Мы превратили $S_1$ в первые $j-1$ символов $S_2$, после чего добавили $b$.
        Аналогично предыдущему случаю, потребовалось $D(i, j-1)+1$ операций.
        \item Оба предыдущих утверждения неверны.
        Если мы добавляли символы справа от финального $a$, то чтобы сделать последним символом $b$, мы должны были или в какой-то момент добавить его (но тогда утверждение 2 было бы верно), либо заменить на него один из этих добавленных символов (что тоже невозможно, потому что добавление символа с его последующей заменой неоптимально).
        Значит, символов справа от финального $a$ мы не добавляли.
        Самого финального $a$ мы не стирали, поскольку утверждение 1 неверно.
        Значит, единственный способ изменения последнего символа --- его замена.
        Заменять его 2 или больше раз неоптимально.
        Значит,
        \begin{enumerate}
            \item Если $a=b$, мы последний символ не меняли.
            Поскольку мы его также не стирали и не приписывали ничего справа от него, он не влиял на наши действия, и, значит, мы выполнили $D(i-1, j-1)$ операций.
            \item Если $a \not= b$, мы последний символ меняли один раз.
            Сделаем эту замену первой.
            В дальнейшем, аналогично предыдущему случаю, мы должны выполнить $D(i-1, j-1)$ операций, значит, всего потребуется $D(i-1, j-1)+1$ операций.
        \end{enumerate}
    \end{enumerate}
\end{proof}

\subsection{Алгоритм Вагнера --- Фишера}

Для нахождения кратчайшего расстояния необходимо вычислить матрицу $D$, используя вышеприведённую формулу.
Её можно вычислять как по строкам, так и по столбцам.
Псевдокод алгоритма, написанный при произвольных ценах замен, вставок и удалений (важно помнить, что элементы нумеруются с 1):

\begin{verbatim}
int levensteinInstruction(String s1, String s2,
        int InsertCost, int DeleteCost, int ReplaceCost):
  D[0][0] = 0
  for j = 1 to N
    D[0][j] = D[0][j - 1] + InsertCost                  
  for i = 1 to M
    D[i][0] = D[i - 1][0] + DeleteCost                  
    for j = 1 to N
      if S1[i] != S2[j] 
         D[i][j] = min(D[i - 1][j] + DeleteCost,        
                       D[i][j - 1] + InsertCost,                      
                       D[i - 1][j - 1] + ReplaceCost)                 
      else 
         D[i][j] = D[i - 1][j - 1]
  return D[M][N]
\end{verbatim}

Этот псевдокод решает простой частный случай, когда вставка символа, удаление символа и замена одного символа на другой стоят одинаково для любых символов.

Алгоритм в виде, описанном выше, требует $\Theta(M \cdot N)$ операций и такую же память, однако, если требуется только расстояние, легко уменьшить требуемую память до $\Theta(N)$.
Заметим, что для вычисления $D[i]$ нам нужно только $D[i-1]$, поэтому будем вычислять $D[i]$ в $D[1]$, а $D[i-1]$ в $D[0]$.
Осталось только поменять местами $D[1]$ и $D[0]$.

\begin{verbatim}
int levensteinInstruction(int[] D):
  for i = 0 to M
    for j = 0 to N
      вычислить D[1][j]
    swap(D[0], D[1])
  return D[0][N]
\end{verbatim}
