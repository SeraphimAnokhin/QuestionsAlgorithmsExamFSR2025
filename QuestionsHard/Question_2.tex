\section{АВЛ-деревья. Повороты, балансировка.}


АВЛ-дерево - сбалансированное двоичное дерево поиска со следующим свойством: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.
Названо в честь изобретателей  Г. М. Адельсона-Вельского и Е. М. Ландиса.

\textbf{Теорема:} АВЛ-дерево имеет высоту $h=O(\log n)$.

\textbf{Доказательство:} Высоту поддерева с корнем $x$ будем обозначать как $h(x)$.
Пусть $m_h$ - минимальное число вершин в АВЛ-дереве высоты $h$. Тогда легко видеть, что $m_{h+2}=m_{h+1}+m_h+1$ по индукции.
Равенством $m_h=F_{h+2}-1$ докажем.

\textbf{База:} $m_1=F_3-1$ - верно, $m_1=1$, $F_3=2$.

\textbf{Шаг:} Допустим $m_h=F_{h+2}-1$ - верно.
Тогда $m_{h+1}=m_h+m_{h-1}+1=F_{h+2}-1+F_{h+1}-1+1 = F_{h+3}-1$.

$F_h=\Omega(\varphi^h)$ где $\varphi=\frac{\sqrt{5}+1}{2}$.
То есть $n \ge \varphi^h \Rightarrow \log_{\varphi} n \ge h$.
Высота АВЛ-дерева из $n$ вершин - $O(\log n)$.

\textbf{Балансировка:}
Балансировкой вершины называется операция, которая в случае разницы высот левого и правого поддеревьев $|h(L)-h(R)|=2$ изменяет связи предок - потомок в поддереве данной вершины так, чтобы восстановилось свойство дерева $|h(L)-h(R)|=1$, иначе ничего не меняет.
$(diff[i]=h(L)-h(R))$.

\textbf{Малое вращение: ($O(1)$)}
\begin{itemize}
	\item Левое используется когда $h(b)-h(L)=2$ и $h(c) \le h(R)$.
	\item Правое используется, когда $h(a)-h(R)=2$ и $h(c) \le h(L)$.
\end{itemize}



\textbf{Большое вращение: ($O(1)$)}
Левое используется когда $h(b)-h(L)=2$ и $h(c)>h(R)$.
Правое используется когда $h(b)-h(R)=2$ и $h(c)>h(L)$.


Большое вращение состоит из двух малых.

\textbf{Вставка (insert):}
Спускаемся по дереву, как при поиске.
Если мы стоим в вершине $a$ и там надо идти в поддерево $b$, то делаем $b$ листом, а вершину $a$ корнем.
Поднимаемся вверх по пути поиска и пересчитываем баланс у вершин.
Если мы поднялись в вершину $i$ из левого поддерева, то $diff[i]=h(L)-h(R)$ увеличилось на 1. Если из правого - уменьшается на 1.
Если пришли в вершину и баланс стал равен 0, то высота не изменилась и подъём останавливается.
Если пришли в вершину и её баланс стал равен 1 или -1, то высота поддерева изменилась и подъём продолжается.
Если пришли в вершину и её баланс стал равен 2 или -2, то делаем одно из 4 вращений и, если после вращения баланс стал 0, то останавливаемся, иначе продолжаем подъём.
Сложность: $O(\log n)$, т.к. в процессе добавления вершины мы рассматриваем не более $O(\log n)$ вершин, и для каждой запускаем балансировку не более одного раза.

\textbf{Удаление (delete):}
Если вершина лист, удаляем её.
Иначе найдём самую близкую по значению вершину и, переместим её на место удаляемой вершины, а затем удалим эту вершину.
От удалённой вершины будем подниматься к корню и пересчитывать баланс у вершин.
$diff[]$ уменьшается.
Если поднялись из левого поддерева, то $diff[]$ уменьшается на 1. Если из правого - увеличивается на 1.
Если пришли в вершину и её баланс стал равен 1 или -1, то высота поддерева не изменилась и подъём можно остановить.
Если пришли в вершину и баланс стал равен 0, то высота поддерева уменьшилась и подъём нужно продолжить.
Если пришли в вершину и её баланс стал равен 2 или -2, то делаем одно из 4 вращений и, если после вращения баланс стал 0, то подъём продолжается, иначе - останавливается.
Аналогично с вставкой: $O(\log n)$.

\textbf{Поиск (find):}
Как в обычном бинарном дереве поиска. $O(\log n)$.