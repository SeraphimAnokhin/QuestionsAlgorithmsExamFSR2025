\section{Бинарные кучи. Реализация с указателями и на массиве. Добавление и удаление элемента в бинарную кучу. }

\begin{definition}
    Двоичная куча или пирамида (англ. Binary heap) --- такое двоичное дерево, для которого выполнены следующие три условия:

    \begin{enumerate}
        \item Значение в любой вершине не больше (если куча для минимума), чем значения в её потомках.
        \item На $i$-м слое (кроме, может быть, последнего) $2^i$ вершин. Слои нумеруются с нуля.
        \item Последний слой заполнен слева направо.
    \end{enumerate}
\end{definition}

Удобнее всего двоичную кучу хранить в виде массива $a[0..n-1]$, у которого нулевой элемент, $a[0]$ --- элемент в корне, а потомками элемента $a[i]$ являются $a[2i+1]$ и $a[2i+2]$.
Высота кучи определяется как высота двоичного дерева.
То есть она равна количеству рёбер в самом длинном простом пути, соединяющем корень кучи с одним из её листьев.
Высота кучи есть $O(\log n)$, где $n$ --- количество узлов дерева.

Чаще всего используют кучи для минимума (когда предок не больше детей) и для максимума (когда предок не меньше детей).

Двоичные кучи используют, например, для того, чтобы извлекать минимум из набора чисел за $O(\log n)$.
Они являются частным случаем приоритетных очередей.

\subsection{Восстановление свойств кучи}

Если в куче изменяется один из элементов, то она может перестать удовлетворять свойству упорядоченности.
Для восстановления этого свойства служат процедуры siftDown (просеивание вниз) и siftUp (просеивание вверх). 

\subsubsection{siftDown}

Если значение измененного элемента увеличивается, то свойства кучи восстанавливаются функцией siftDown.

Работа процедуры: если $i$-й элемент меньше, чем его сыновья, всё поддерево уже является кучей, и делать ничего не надо.
В противном случае меняем местами $i$-й элемент с наименьшим из его сыновей, после чего выполняем siftDown для этого сына.
Процедура выполняется за время $O(\log n)$.

\begin{verbatim}
function siftDown(i : int):
    while 2 * i + 1 < a.heapSize     // heapSize — количество элементов в куче
        left = 2 * i + 1             // left — левый сын
        right = 2 * i + 2            // right — правый сын
        j = left
        if right < a.heapSize and a[right] < a[left]
            j = right
        if a[i] <= a[j]
            break
        swap(a[i], a[j])
        i = j
\end{verbatim}

\subsubsection{siftUp}

Если значение измененного элемента уменьшается, то свойства кучи восстанавливаются функцией siftUp.

Работа процедуры: если элемент больше своего отца, условие 1 соблюдено для всего дерева, и больше ничего делать не нужно.
В противном случае мы меняем местами его с отцом, после чего выполняем siftUp для этого отца.
Иными словами, слишком маленький элемент всплывает наверх.
Процедура выполняется за время $O(\log n)$.

\begin{verbatim}
function siftUp(i : int):
    while a[i] < a[(i - 1) / 2]     // i = 0 - мы в корне
        swap(a[i], a[(i - 1) / 2])
        i = (i - 1) / 2
\end{verbatim}

\subsection{Извлечение минимального элемента}

Выполняет извлечение минимального элемента из кучи за время $O(\log n)$.
Извлечение выполняется в четыре этапа:

\begin{enumerate}
    \item Значение корневого элемента (он и является минимальным) сохраняется для последующего возврата.
    \item Последний элемент копируется в корень, после чего удаляется из кучи.
    \item Вызывается siftDown для корня.
    \item Сохранённый элемент возвращается.
\end{enumerate}

\begin{verbatim}
int extractMin():
    int min = a[0]
    a[0] = a[a.heapSize - 1]
    a.heapSize = a.heapSize - 1
    siftDown(0)
    return min
\end{verbatim}

\subsection{Добавление нового элемента}

Выполняет добавление элемента в кучу за время $O(\log n)$.
Сначала производится добавление произвольного элемента в конец кучи, затем восстановление свойства упорядоченности с помощью процедуры siftUp.

\begin{verbatim}
function insert(key : int):
    a.heapSize = a.heapSize + 1
    a[a.heapSize - 1] = key
    siftUp(a.heapSize - 1)
\end{verbatim}

\subsection*{Реализация на указателях}
Для реализации кучи на указателях понадобится представить её в виде обычного бинарного дерева, один элемент которого будет содержать в себе указатель на левого, правого потомков и родителя.
Пример на языке Си

\begin{verbatim}
struct heap_node{
    int key;
    struct heap_node *right, *left, *parent;
};
\end{verbatim}

Операции